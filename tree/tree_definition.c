//
// Created by Administrator on 4/6/2021.
//

// 树是n个结点的有限集, 当n=0时 称这个树为空树
// 在任一一个非空树中, 仅有一个特定的结点称为根结点
// 当n>1时 树可以分为m(m>0)个互不相交的有限集

// 树的根结点没有前驱, 除了根结点之外均只有一个前驱
// 树的所有结点可以有0个或者多个后继

// 结点有n个分支则称这个结点的度为n, n>0的结点称为分支结点, n=0的结点称为叶子结点,即没有分支的结点为叶子结点

// 结点的双亲  结点的兄弟:有相同的双亲  在同一层次: 互为堂兄弟
// 深度: 从上到下   高度: 从下到上  层次: 根结点在第一层

// 结点的子树从左到右是有次序的, 则称树为有序树, 否则称为无序树

// 路径: 由两个结点之间所经过的结点序列构成的
// 路径长度: 路径上所经过的边的个数   注意: 树的分支是有向的, 树中的路径都是从上至下的, 从双亲指向孩子, 所以同一双亲的两个孩子之间不存在路径

// 森林, 由m棵不相交的树组成, 即:如果把这m棵独立的树加上一个公共的根结点, 则这个森林就变成了树

// 性质1: 度为m的树 第i层最多有 m^(i-1) 个结点  即每一层都是最多的结点, m不停的乘就可以了

// 性质2: 高度为n的m叉树, 最多结点数为: 1+m+m^2+...+m^n-1 =  1* ( m^n  - 1 ) / (m - 1)
// 注意等比数列的求和公式, 如果是从0~n-1, 那实际上总共是n个


###
// 二叉树
// 它与度为2的树的区别:
// 1. 度为2的树说明它一定有分支, 最少有三个结点, 而二叉树可以为空
// 2. 度为2的树的顺序是相对于其他孩子来说的, 如果一个结点只有一个孩子,那么这个孩子就无需区分左右次序,
// 而二叉树无论这个结点有一个结点还是有两个结点, 孩子的次序都是已经确定了的,因为它是有序树, 即使只有一个结点,也需要考虑它是左子树还是右子树

####

满二叉树

// 性质 1. 总结点数为2^n - 1, n 为高度
// 2. 从左往右, 从上到下排序, 那么结点i的左孩子序号为2i, 右孩子为2i+1, 双亲为i/2取较小的部分

// 完全二叉树: 从1~n序号的结点和满二叉树一致
// 性质1. 若序号<=n/2,则是分支结点, 如果>n/2,那么是叶子结点
// 2.叶子结点只可能在最大的两个层次上出现, 并且最大的层次上的叶子结点,都从左边开始往右排
// 3.若有度为1的结点,那么只可能有一个,而且这个结点只有一个左孩子
//4. 排序后,如果遇到第n个结点是叶子结点或者只有一个左孩子,那么大于n的结点都是叶子结点
// 5. 如果结点数为偶数,那么最大分支结点(n/2)只有左孩子,其余分支结点左右孩子都有,如果结点数为奇数, 那么所有分支结点都有左右孩子

// 最小高度对应最多结点
// 已知结点-> 最小高度
// 已知高度->最多结点
// 已知高度->最少结点

// 完全二叉树 在第n层有叶子结点-> 等价于: 不止有叶子结点,还可能有分支结点, 这个二叉树可能有n行或n+1行


// 今天记住的几个性质:
// 1. 二叉树的第n层有2的n-1次方个结点
// 2.已知深度/高度为n层, 那么最多结点为 2的n次方-1, 这个是等比数列求和公式算出来的, 分母由于是q-1, q=2, 导致分母变为1了
// 最少的层次为 2的n-1次方减一再加一, 是第n层只有一个的情况

// 分支结点和叶子结点

// 二叉树的结点逻辑
// 1. 如果一个二叉树有i个结点, 那么它的双亲的结点数为i/2取整, 如果它是偶数,那么是左孩子,如果是奇数,那么是右孩子






void NLR_PreOrder(Btree T) {
    if (T != NULL) {
        visit(T);
        NLR_PreOrder(T->lchild);
        NLR_PreOrder(T->rchile);
    }
}

// 图Graph Vertex edge

G
        V = (2, 3);
// E(G) = {<2,3>,<3,2>}
// E(G) = {(2,3),(3,2)}

// 简单图: 不存在自己到自己的边, 没有重复的边
// 多重图: 有顶点自身到顶点自身的边, 允许重复的边




















